TIL Daily Log

January 2023

1.1 - Concept: Spread syntax (...), Language/Framework: JavaScript

TIL... The spread syntax (...) expression, introduced in ES6, allows you to "expand" an iterable, such as an array or string, into its individual elements in places where zero or more arguments (for function calls) or elements (for array literals) are expected. For object literals, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created. (MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

function fullBirbName(x, y) {
    return x + " " + y;
}

const grayCatbird = ["Gray", "Catbird"];

console.log(fullBirbName(...grayCatbird));
// expected output: Gray Catbird
// without spread syntax, the expect output would be: Gray,Catbird undefined

Additional reading: freeCodeCamp - https://www.freecodecamp.org/news/an-introduction-to-spread-syntax-in-javascript-fba39595922c/

1.2 - Concept: Iterating over an object's properties wit a for...in loop, Language/Framework: JavaScript

TIL... You can use a for...in loop to iterate over an object and perform operation the object's property names and corresponding values. (MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)

const carolinaWren = { "Common name": "Carolina Wren", "Binomial name": "Thryothorus ludovicianus", "Family": "Wrens", "Habitat": "Dense forest, farm edges, and suburban areas" };

for (const property in carolinaWren) {
    console.log(`${property}: ${carolinaWren[property]}`);
}
/* expected output:
    Common name: Carolina Wren
    Binomial name: Thyrothorus ludovicianus
    Family: Wrens
    Habitat: Dense forest, farm edges, and suburban areas */

1.3 - Concept: Calculating the sum of an array using the forEach() method, Language/Framework: JavaScript

TIL... You can use the JavaScript forEach() method to find the sum of an array with numbers. The arr.forEach() method will call the provided function once for each element of the array. (GeeksforGeeks - https://www.geeksforgeeks.org/how-to-find-the-sum-of-all-elements-of-a-given-array-in-javascript/)

let triangleSides = [1, 1, 1];

function trianglePerimeter(arr) {
    let sum = 0;
    arr.forEach(x => {
        sum += x;
    })
    return sum;
}

console.log(trianglePerimeter(triangleSides));
// expected output: 3

1.6 Concept: Array.prototype.reduce(), Language/Framework: JavaScript

TIL... The reduce() method will execute a "reducer" callback function on each element of the array, much like the forEach() method. This iterative method will start at the array's first index and will accumulate the return value from the calculation over all the elements of the array in ascending-index order.

Syntax: 
    reduce((accumulator, currentValue) => {}) or
    reduce(callbackFn/accumulator, initial value)

callbackFn: the function executed on each element in the array; it's return value becomes the value of the "accumulator" on the next invocation of callbackFn. On the last invocation, you get the return value of reduce().

accumulator: the value resulting from the previous call to callbackFn; if initalValue is specified, that will be accumulator on first call, otherwise it will be array[0].

currentValue: the value of the current element; the value of array[0] on first call if initialValue is specified, otherwise it's the value of array[1].

currentIndex: the index position of currentValue; 0 if initialValue is specified, otherwise it is 1.

(MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

If we use the same example from 1.3.23, we can refactor the code to look like this:

const triangleSides = [1, 1, 1];

// 0 + 1 + 1 + 1
const initialValue = 0;
const trianglePerimeter = triangleSides.reduce(
    (accumulator, currentValue) => accumulator + currentValue,
    initialValue
);

console.log(trianglePerimeter);
// expected output: 3

1.14 - Concept: Enclosing scope context for arrow functions, Language/Framework: JavaScript

TIL... Arrow functions do not have their own "execution context" which means that both 'this' and 'arguments' are inherited from their parent function. (Zendev - https://zendev.com/2018/10/01/javascript-arrow-functions-how-why-when.html)

For instance:

const test = {
  name: 'test object',
  createAnonFunction: function() {
    return function() {
      console.log(this.name);
      console.log(arguments);
    };
  },

  createArrowFunction: function() {
    return () => {
      console.log(this.name);
      console.log(arguments);
    };
  }
};

const anon = test.createAnonFunction('hello', 'world');
const arrow = test.createArrowFunction('hello', 'world');

> anon();
undefined
{}

> arrow();
test object
{ '0': 'hello', '1': 'world' }

The anonymous function has its own function context, therefore there is no reference available to the 'this.name' of the test object or the arguments being called.

The arrow function has the exact same function contest as the function that created it. It has access to both the arguments being called and the test object.

1.15 - Concept: Using arrow function expressions as methods, Language/Framework: JavaScript

You cannot use arrow function expressions as methods.

Arrow functions work differently compared to regular functions. With arrow functions, there are no binding of the keyword 'this'. For regular functions, the 'this' keyword represents the object that called the function. Therefore, for arrow functions, the 'this' keyword ALWAYS represents the object that defined the arrow function.

Watch what happens:

const birbs = {
    a: mockingbird,
    b: () => console.log(this.a, this),
    c() {
        console.log(this.a, this);
    },
};

birbs.b(); // logs undefined, Window { /* ... */ } (or the global object)
birbs.c(); // logs mockingbird, Object {a: 'mockingbird', b: function, c: function}

So what happened here?

A class's body has a 'this' context. Arrow functions, as class fields, will close over, or supersede, the class's this context. The 'this' inside of the arrow functions body will point to the instance, or the class itself for static fields. Because of this closure, the value of 'this' will not change based on the context of the execution and the function's own binding becomes irrelevant.

w3schools - https://www.w3schools.com/Js/js_arrow_function.asp

MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#cannot_be_used_as_methods

1.16 - Concept: Double NOT (!!) & Logical complement/negation, Language/Framework: JavaScript

The double NOT (!!) operator is the antithesis or direct opposite of the logical NOT (!) operator. The logical NOT (!) operator, also affectionately known as "bang", is typically used with boolean (logical) values and makes them truthy or falsy (true or false) based on their boolean primitive value. Primitive values are the values associated with the predefined data types provided by JavaScript language; also known as "built-in" data types.

While the logical NOT (!) is used with operands that aren't Boolean values, it is still considered to be a boolean operator because its return value can always be converted to a boolean primitive.

not1 = !true // will return false; true is truthy
not2 = !false // will return true; false is falsy
not3 = !'' // will return true; empty strings ('') are falsy
not4 = !'mockingbird' // will return false; strings are truthy

The double NOT (!!) is essentially a function that will explicitily force the conversion of any value to the corresponding boolean primitive.

doubleNot1 = !!true // will return true; true is truthy
doubleNot2 = !!false // will return false; false is falsy
doubleNot3 = !!'' // will return false; empty strings ('') are falsy
doubleNot4 = !!'mockingbird' // will return true; strings are truthy

Another way to use this type of conversion is though the Boolean function:

b1 = Boolean(true) // will return true
b2 = Boolean(false) // will return false
b3 = !Boolean(true) // will return false
b4 = !Boolean(false) // will return true
b5 = !!Boolean(true) // will return true
b6 = !!Boolean(false) // will return false

References:

MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT#double_not_!!
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#boolean_type
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean#boolean_coercion

GeeksforGeeks - https://www.geeksforgeeks.org/primitive-and-non-primitive-data-types-in-javascript/

1.18 - Concept: All objects are truthy -- including empty objects, Language/Framework: JavaScript

In JavaScript, nearly all objects are instances of 'Object'. Typically, objects will inherit properties and methods from 'Object.prototype'. empty object inherits properties from its prototype 'Object.prototype' as a default. Prototype is a JavaScript property that allows you to add new properties to object constructors. Inheritance in JavaScript refers to the property of objects inheriting, or acquiring, all the properties and behaviors of the parent object.

  * 'Date' objects inherit from 'Date.prototype'
  * 'Array' objects inherit from 'Array.prototype'
  * 'Person' objects inherit from 'Person.prototype'

In essence, the 'Object.prototype' is on the top of the "prototype inheritance food chain"; 'Date', 'Array', and 'Person' objects, for example, all inherit from 'Object.prototype'.

// Object constructor syntax (2 ways):
new Object(value)
Object(value)

'value' is any value.

The constructor input gets turned into into an object. The objects behavior is determined by the input's type. The Object() constructor will return an object of a Type that corresponds to the given value:

const five = new Object(5);
Object.getPrototypeOf(five); // returns Number

If the value being passed into the constructor is an object, it will return the value of the object:

const kingJames = { name: 'LeBron James', age: 38, height: '6 ft 9 in' };
const lilGoat = new Object(kingJames);
console.log(lilGoat); // returns {name: 'LeBron James', age: 38, height: '6 ft 9 in'}

Otherwise, if the value being passed in is 'null' or 'undefined', it creates and return an empty object ({}). It's important to note that both 'null' and 'undefined' are falsy, or not true in a Boolean sense.

// Create an empty object:
const o1 = new Object(); // returns {} - [[Prototype]]: Object
const o2 = Object(); // returns {} - [[Prototype]]: Object

// Undefined an null types as the value being passed in
const o3 = new Object(undefined);
const o4 = Object(undefined);
const o5 = new Object(null);
const o6 = Object(null);

All 6 of these variables will log '{}', an empty object with properties inherited from the 'Object prototype'.

With that being said, even when Objects are empty, or being constructed without any new properties or methods, or with null and undefined types, they are still truthy. This is because they have inherited properties from 'Object.prototype'.

// Boolean check - wha wha???
const b1 = Boolean(o1); // will return true
const b2 = Boolean(o2); // will return true
const b3 = Boolean(o3); // will return true
const b4 = Boolean(o4); // will return true
const b5 = Boolean(o5); // will return true
const b6 = Boolean(o6); // will return true

TRUUUUUUUUUUUUUUUUUUUUU

References:

w3schools - https://www.w3schools.com/js/js_object_prototypes.asp

w3schools.blog - https://www.w3schools.blog/inheritance-javascript-js

MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/Object


1.19.23 - Concept: Objects with falsy values are truthy, Language/Framework: JavaScript

const o7 = Object(false);
const o8 = Object(0);
const o9 = Object(-0);
const o10 = Object('');
const o11 = Object(NaN);

const b7 = Boolean(o7);
const b8 = Boolean(o8);
const b9 = Boolean(o9);
const b10 = Boolean(o10);
const b11 = Boolean(o11);